# database.py
import cx_Oracle
import json
from datetime import datetime
from typing import Dict, Any, Optional

class DatabaseManager:
    """Manage Oracle database operations for ISTVON logging"""
    
    def __init__(self):
        # Oracle connection parameters
        self.dsn = "localhost:1521/XEPDB1"
        self.username = "heman"
        self.password = "password"
        self.connection = None
        self.setup_database()
    
    def get_connection(self):
        """Get Oracle database connection"""
        try:
            if self.connection is None:
                self.connection = cx_Oracle.connect(
                    user=self.username,
                    password=self.password,
                    dsn=self.dsn
                )
            return self.connection
        except cx_Oracle.Error as e:
            print(f"Oracle connection error: {e}")
            return None
    
    def close_connection(self):
        """Close Oracle database connection"""
        if self.connection:
            self.connection.close()
            self.connection = None
    
    def setup_database(self):
        """Initialize database with required tables"""
        conn = self.get_connection()
        if not conn:
            print("Failed to connect to Oracle database")
            return
        
        cursor = conn.cursor()
        
        try:
            # Create prompt_log table with the specified schema
            cursor.execute('''
                CREATE TABLE prompt_log (
                    id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                    timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    original_prompt CLOB NOT NULL,
                    verdict VARCHAR2(20) NOT NULL,
                    reason CLOB,
                    sanitized_prompt CLOB,
                    final_response CLOB,
                    istvon_map_json CLOB NOT NULL
                )
            ''')
            print("✅ prompt_log table created successfully")
        except cx_Oracle.Error as e:
            if "ORA-00955" in str(e):  # Table already exists
                print("✅ prompt_log table already exists")
            else:
                print(f"Error creating table: {e}")
        
        try:
            conn.commit()
        except cx_Oracle.Error as e:
            print(f"Error committing changes: {e}")
        finally:
            cursor.close()
    
    def log_transformation(self, original_prompt: str, istvon_json: Dict, 
                          success: bool, domain: str = "auto", 
                          processing_time: int = 0, verdict: str = None,
                          reason: str = None, sanitized_prompt: str = None,
                          response: str = None):
        """Log a prompt transformation to the Oracle database"""
        conn = self.get_connection()
        if not conn:
            print("Failed to connect to Oracle database")
            return False
        
        cursor = conn.cursor()
        
        try:
            # Map verdict based on success
            if verdict is None:
                verdict = "ALLOW" if success else "BLOCK"
            
            cursor.execute('''
                INSERT INTO prompt_log 
                (timestamp, original_prompt, verdict, reason, sanitized_prompt, final_response, istvon_map_json)
                VALUES (CURRENT_TIMESTAMP, :1, :2, :3, :4, :5, :6)
            ''', (
                original_prompt,
                verdict,
                reason,
                sanitized_prompt,
                response,
                json.dumps(istvon_json)
            ))
            
            conn.commit()
            return True
            
        except cx_Oracle.Error as e:
            print(f"Error logging transformation: {e}")
            conn.rollback()
            return False
        finally:
            cursor.close()
    
    def get_analytics(self) -> Dict[str, Any]:
        """Get transformation analytics"""
        conn = self.get_connection()
        if not conn:
            return {"total_transformations": 0, "avg_prompt_length": 0, "success_rate": 0}
        
        cursor = conn.cursor()
        
        try:
            cursor.execute('''
                SELECT 
                    COUNT(*) as total,
                    AVG(LENGTH(original_prompt)) as avg_length,
                    COUNT(CASE WHEN verdict = 'ALLOW' THEN 1 END) * 100.0 / COUNT(*) as success_rate
                FROM prompt_log
            ''')
            
            result = cursor.fetchone()
            
            return {
                "total_transformations": result[0] or 0,
                "avg_prompt_length": round(result[1] or 0, 1),
                "success_rate": round(result[2] or 0, 1)
            }
        except cx_Oracle.Error as e:
            print(f"Error getting analytics: {e}")
            return {"total_transformations": 0, "avg_prompt_length": 0, "success_rate": 0}
        finally:
            cursor.close()
    
    def get_recent_transformations(self, limit: int = 5):
        """Get recent transformations for display"""
        conn = self.get_connection()
        if not conn:
            return []
        
        cursor = conn.cursor()
        
        try:
            cursor.execute('''
                SELECT original_prompt, istvon_map_json, timestamp, verdict
                FROM prompt_log 
                ORDER BY timestamp DESC 
                FETCH FIRST :1 ROWS ONLY
            ''', (limit,))
            
            results = cursor.fetchall()
            
            return [
                {
                    "prompt": str(row[0])[:100] + "..." if len(str(row[0])) > 100 else str(row[0]),
                    "timestamp": row[2].strftime("%Y-%m-%d %H:%M:%S") if hasattr(row[2], 'strftime') else str(row[2]),
                    "success": row[3] == "ALLOW"
                }
                for row in results
            ]
        except cx_Oracle.Error as e:
            print(f"Error getting recent transformations: {e}")
            return []
        finally:
            cursor.close()
    
    def get_sanitized_prompts(self, limit: int = 10):
        """Get recent sanitized prompts for display"""
        conn = self.get_connection()
        if not conn:
            return []
        
        cursor = conn.cursor()
        
        try:
            cursor.execute('''
                SELECT original_prompt, istvon_map_json, sanitized_prompt, timestamp, verdict
                FROM prompt_log 
                WHERE sanitized_prompt IS NOT NULL AND sanitized_prompt != ''
                ORDER BY timestamp DESC 
                FETCH FIRST :1 ROWS ONLY
            ''', (limit,))
            
            results = cursor.fetchall()
            
            return [
                {
                    "original_prompt": str(row[0]),
                    "istvon_json": json.loads(str(row[1])) if row[1] else {},
                    "sanitized_prompt": str(row[2]) if row[2] else "",
                    "timestamp": row[3].strftime("%Y-%m-%d %H:%M:%S") if hasattr(row[3], 'strftime') else str(row[3]),
                    "verdict": row[4]
                }
                for row in results
            ]
        except cx_Oracle.Error as e:
            print(f"Error getting sanitized prompts: {e}")
            return []
        finally:
            cursor.close()
    
    def import_from_json_file(self, json_filepath: str) -> bool:
        """Import response data from a JSON file and store in database"""
        try:
            with open(json_filepath, 'r', encoding='utf-8') as f:
                response_data = json.load(f)
            
            # Handle both old and new JSON structure
            if 'original_prompt' in response_data:
                # New structure (direct Oracle schema mapping)
                original_prompt = response_data.get('original_prompt', '')
                verdict = response_data.get('verdict', 'ALLOW')
                reason = response_data.get('reason', 'Imported from JSON')
                sanitized_prompt = response_data.get('sanitized_prompt')
                final_response = response_data.get('final_response', '')
                istvon_data = response_data.get('istvon_map_json', {})
                metadata = response_data.get('metadata', {})
                processing_time = metadata.get('processing_time_ms', 0)
            else:
                # Old structure (legacy support)
                metadata = response_data.get('metadata', {})
                input_data = response_data.get('input', {})
                istvon_data = response_data.get('istvon_framework', {})
                context = response_data.get('context_analysis', {})
                generated_response = response_data.get('generated_response', '')
                
                original_prompt = input_data.get('original_prompt', '')
                verdict = metadata.get('verdict', 'ALLOW')
                reason = metadata.get('reason', 'Imported from JSON')
                sanitized_prompt = input_data.get('sanitized_prompt')
                final_response = generated_response
                processing_time = metadata.get('processing_time_ms', 0)
            
            # Log to database
            return self.log_transformation(
                original_prompt=original_prompt,
                istvon_json=istvon_data,
                success=verdict == 'ALLOW',
                domain='auto',
                processing_time=processing_time,
                verdict=verdict,
                reason=reason,
                sanitized_prompt=sanitized_prompt,
                response=final_response
            )
            
        except Exception as e:
            print(f"Error importing from JSON file: {str(e)}")
            return False
    
    def get_response_by_timestamp(self, timestamp: str):
        """Get response data by timestamp"""
        conn = self.get_connection()
        if not conn:
            return None
        
        cursor = conn.cursor()
        
        try:
            cursor.execute('''
                SELECT id, timestamp, original_prompt, verdict, reason, 
                       sanitized_prompt, final_response, istvon_map_json
                FROM prompt_log 
                WHERE TO_CHAR(timestamp, 'YYYY-MM-DD HH24:MI:SS') LIKE :1
                ORDER BY timestamp DESC
            ''', (f"%{timestamp}%",))
            
            result = cursor.fetchone()
            
            if result:
                return {
                    "id": result[0],
                    "timestamp": result[1].strftime("%Y-%m-%d %H:%M:%S") if hasattr(result[1], 'strftime') else str(result[1]),
                    "original_prompt": str(result[2]),
                    "verdict": result[3],
                    "reason": str(result[4]) if result[4] else "",
                    "sanitized_prompt": str(result[5]) if result[5] else "",
                    "final_response": str(result[6]) if result[6] else "",
                    "istvon_map_json": json.loads(str(result[7])) if result[7] else {}
                }
            return None
        except cx_Oracle.Error as e:
            print(f"Error getting response by timestamp: {e}")
            return None
        finally:
            cursor.close()